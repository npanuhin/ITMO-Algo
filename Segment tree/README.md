<!-- {#title ​Дерево отрезков} -->

<h1 align="center">Дерево отрезков</h1>


## A. Дерево отрезков на сумму

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

В этой задаче вам нужно написать обычное дерево отрезков на сумму.

### Входные данные
Первая строка содержит два числа <span tex="n">n</span> и <span tex="m">m</span> <span tex="(1 ⩽ n, m ⩽ 100\ 000)">(1 ⩽ n, m ⩽ 100\ 000)</span> — размер массива и число операций. Следующая строка содержит <span tex="n">n</span> чисел <span tex="a_i">a_i</span> — начальное состояние массива <span tex="(0 ⩽ a_i ⩽ 10^9)">(0 ⩽ a_i ⩽ 10^9)</span>. Далее следует описание операций. Описание каждой операции имеет следущий вид:

- 1 <span tex="i">i</span> <span tex="v">v</span> — присвоить элементу с индексом <span tex="i">i</span> значение <span tex="v">v</span> <span tex="(0 ⩽ i < n, 0 ⩽ v ⩽ 10^9)">(0 ⩽ i < n, 0 ⩽ v ⩽ 10^9)</span>.
- 2 <span tex="l">l</span> <span tex="r">r</span> — вычислить сумму элементов с индексами от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> <span tex="(0 ⩽ l < r ⩽ n)">(0 ⩽ l < r ⩽ n)</span>.

### Выходные данные
Для каждой операции второго типа выведите соответствующую сумму.

### Пример
Входные данные
```cpp
5 5
5 4 2 3 5
2 0 3
1 1 1
2 0 3
1 3 1
2 0 5
```

Выходные данные
```cpp
11
8
14
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/A.cpp)


## B. Число минимумов на отрезке

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

Теперь измените код дерева отрезков, чтобы кроме минимума на отрезке считалось также и число элементов, равных минимуму.

### Входные данные
Первая строка содержит два числа <span tex="n">n</span> и <span tex="m">m</span> <span tex="(1 ⩽ n, m ⩽ 100\ 000)">(1 ⩽ n, m ⩽ 100'000)</span> — размер массива и число операций. Следующая строка содержит <span tex="n">n</span> чисел <span tex="a_i">a_i</span> — начальное состояние массива <span tex="(0 ⩽ a_i ⩽ 10^9)">(0 ⩽ a_i ⩽ 10^9)</span>. Далее следует описание операций. Описание каждой операции имеет следущий вид:

- 1 <span tex="i">i</span> <span tex="v">v</span> — присвоить элементу с индексом <span tex="i">i</span> значение <span tex="v">v</span> <span tex="(0 ⩽ i < n,">(0 ⩽ i < n,</span> <span tex="0 ⩽ v ⩽ 10^9)">0 ⩽ v ⩽ 10^9)</span>.
- 2 <span tex="l">l</span> <span tex="r">r</span> — найти минимум и число элементов, равных минимуму, среди элементов с индексами от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> <span tex="(0 ⩽ l < r ⩽ n)">(0 ⩽ l < r ⩽ n)</span>.

### Выходные данные
Для каждой операции второго типа выведите два числа — минимум на заданном отрезке и число элементов, равных этому минимуму.

### Пример
Входные данные
```cpp
5 5
3 4 3 5 2
2 0 3
1 1 2
2 0 3
1 0 2
2 0 5
```

Выходные данные
```cpp
3 2
2 1
2 3
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/B.cpp)


## C. Отрезок с максимальной суммой

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

В этой задаче вам нужно написать дерево отрезков для нахождения подотрезка с максимальной суммой.

### Входные данные
Первая строка содержит два числа <span tex="n">n</span> и <span tex="m">m</span> <span tex="(1 ⩽ n, m ⩽ 100\ 000)">(1 ⩽ n, m ⩽ 100'000)</span> — размер массива и число операций. Следующая строка содержит <span tex="n">n</span> чисел <span tex="a_i">a_i</span> — начальное состояние массива <span tex="(-10^9 ⩽ a_i ⩽ 10^9)">(-10^9 ⩽ a_i ⩽ 10^9)</span>. Далее следует описание операций. Описание каждой операции имеет следующий вид: <span tex="i">i</span> <span tex="v">v</span> — присвоить элементу с индексом <span tex="i">i</span> значения <span tex="v">v</span> <span tex="(0 ⩽ i < n,">(0 ⩽ i < n,</span> <span tex="-10^9 ⩽ v ⩽ 10^9)">-10^9 ⩽ v ⩽ 10^9)</span>.

### Выходные данные
Выведите <span tex="m + 1">m + 1</span> строку: максимальную сумму чисел на отрезке до всех операций и после каждой операции. Обратите внимание, что этот отрезок может быть пустым (при этом сумма на нем будет равна 0)

### Пример
Входные данные
```cpp
5 2
5 -4 4 3 -5
4 3
3 -1
```

Выходные данные
```cpp
8
11
7
```

Входные данные
```cpp
4 2
-2 -1 -5 -4
1 3
3 2
```

Выходные данные
```cpp
0
3
3
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/C.cpp)


## D. K-я единица

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

В этой задаче вам нужно добавить в дерево отрезков операцию нахождения <span tex="k">k</span>-й единицы.

### Входные данные
Первая строка содержит два числа <span tex="n">n</span> и <span tex="m">m</span> <span tex="(1 ⩽ n, m ⩽ 100\ 000)">(1 ⩽ n, m ⩽ 100'000)</span> — размер массива и число операций. Следующая строка содержит <span tex="n">n</span> чисел <span tex="a_i">a_i</span> — начальное состояние массива <span tex="(a_i ∈ \{0, 1\})">(a_i ∈ \{0, 1\})</span>. Далее следует описание операций. Описание каждой операции имеет следущий вид:

- 1 <span tex="i">i</span> — изменить элемент с индексом <span tex="i">i</span> на противоположный.
- 2 <span tex="k">k</span> — найти <span tex="k">k</span>-ю единицу (единицы нумеруются с 0, гарантируется, что в массиве достаточное количество единиц).

### Выходные данные
Для каждой операции второго типа выведите индекс соответствующей единицы (все индексы в этой задаче от 0).

### Пример
Входные данные
```cpp
5 7
1 1 0 1 0
2 0
2 1
2 2
1 2
2 3
1 0
2 0
```

Выходные данные
```cpp
0
1
3
3
1
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/D.cpp)


## E. Первый элемент не меньше X - 2

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

В этой задаче вам нужно добавить в дерево отрезков операцию нахождения по данным <span tex="x">x</span> и <span tex="l">l</span> минимального индекса <span tex="j">j</span>, для которого <span tex="j ⩾ l">j ⩾ l</span> и <span tex="a[j] ⩾ x">a\[j\] ⩾ x</span>.

### Входные данные
Первая строка содержит два числа <span tex="n">n</span> и <span tex="m">m</span> <span tex="(1 ⩽ n, m ⩽ 100\ 000)">(1 ⩽ n, m ⩽ 100'000)</span> — размер массива и число операций. Следующая строка содержит <span tex="n">n</span> чисел <span tex="a_i">a_i</span> — начальное состояние массива <span tex="(0 ⩽ a_i ⩽ 10^9)">(0 ⩽ a_i ⩽ 10^9)</span>. Далее следует описание операций. Описание каждой операции имеет следущий вид:

- 1 <span tex="i">i</span> <span tex="v">v</span> — изменить элемент с индексом <span tex="i">i</span> на <span tex="v">v</span> <span tex="(0 ⩽ i < n, 0 ⩽ v ⩽ 10^9)">(0 ⩽ i < n, 0 ⩽ v ⩽ 10^9)</span>.
- 2 <span tex="x">x</span> <span tex="l">l</span> — найти минимальный индекс <span tex="j">j</span>, для <span tex="j ⩾ l">j ⩾ l</span> и <span tex="a[j] ⩾ x">a\[j\] ⩾ x</span> <span tex="(0 ⩽ x ⩽ 10^9,">(0 ⩽ x ⩽ 10^9,</span> <span tex="0 ⩽ l < n)">0 ⩽ l < n)</span>. Если такого элемента нет, выведите <span tex="-1">-1</span>. Индексы начинаются с 0.

### Выходные данные
Для каждой операции второго типа выведите ответ на запрос.

### Пример
Входные данные
```cpp
5 7
1 3 2 4 3
2 3 0
2 3 2
1 2 5
2 4 1
2 5 4
1 3 7
2 6 1
```

Выходные данные
```cpp
1
3
2
-1
3
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/E.cpp)


## F. Прибавление и минимум

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

Есть массив из <span tex="n">n</span> элементов, изначально заполненный нулями. Вам нужно написать структуру данных, которая обрабатывает два вида запросов:

- прибавить к отрезку от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> число <span tex="v">v</span>,
- узнать минимум на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span>.

### Входные данные
Первая строка содержит два числа <span tex="n">n</span> и <span tex="m">m</span> <span tex="(1 ⩽ n, m ⩽ 100\ 000)">(1 ⩽ n, m ⩽ 100'000)</span> — размер массива и число операций. Далее следует описание операций. Описание каждой операции имеет следущий вид:

- 1 <span tex="l">l</span> <span tex="r">r</span> <span tex="v">v</span> — прибавить значение <span tex="v">v</span> к отрезку от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> <span tex="(0 ⩽ l < r ⩽ n,">(0 ⩽ l < r ⩽ n,</span> <span tex="0 ⩽ v ⩽ 10^9)">0 ⩽ v ⩽ 10^9)</span>.
- 2 <span tex="l">l</span> <span tex="r">r</span> — узнать минимум на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> <span tex="(0 ⩽ l < r ⩽ n)">(0 ⩽ l < r ⩽ n)</span>.

### Выходные данные
Для каждой операции второго типа выведите соответствующее значение.

### Пример
Входные данные
```cpp
5 6
1 0 3 3
2 1 2
1 1 4 4
2 1 3
2 1 4
2 3 5
```

Выходные данные
```cpp
3
7
4
0
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/F.cpp)


## G. Присваивание и минимум

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

Есть массив из <span tex="n">n</span> элементов, изначально заполненный нулями. Вам нужно написать структуру данных, которая обрабатывает два вида запросов:

- присвоить всем элементам на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> значение <span tex="v">v</span>,
- узнать минимум на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span>.

### Входные данные
Первая строка содержит два числа <span tex="n">n</span> и <span tex="m">m</span> <span tex="(1 ⩽ n, m ⩽ 100\ 000)">(1 ⩽ n, m ⩽ 100'000)</span> — размер массива и число операций. Далее следует описание операций. Описание каждой операции имеет следущий вид:

- 1 <span tex="l">l</span> <span tex="r">r</span> <span tex="v">v</span> — присвоить всем элементам на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> значение <span tex="v">v</span> <span tex="(0 ⩽ l < r ⩽ n, 0 ⩽ v ⩽ 10^9)">(0 ⩽ l < r ⩽ n, 0 ⩽ v ⩽ 10^9)</span>.
- 2 <span tex="l">l</span> <span tex="r">r</span> — узнать минимум на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> <span tex="(0 ⩽ l < r ⩽ n)">(0 ⩽ l < r ⩽ n)</span>.

### Выходные данные
Для каждой операции второго типа выведите соответствующее значение.

### Пример
Входные данные
```cpp
5 6
1 0 3 3
2 1 2
1 1 4 4
2 1 3
2 1 4
2 3 5
```

Выходные данные
```cpp
3
4
4
0
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/G.cpp)


## H. Присваивание, прибавление и сумма

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

Есть массив из <span tex="n">n</span> элементов, изначально заполненный нулями. Вам нужно написать структуру данных, которая обрабатывает три вида запросов:

- присвоить всем элементам на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> значение <span tex="v">v</span>,
- прибавить ко всем элементам на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> число <span tex="v">v</span>,
- узнать сумму на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span>.

### Входные данные
Первая строка содержит два числа <span tex="n">n</span> и <span tex="m">m</span> <span tex="(1 ⩽ n, m ⩽ 100\ 000)">(1 ⩽ n, m ⩽ 100'000)</span> — размер массива и число операций. Далее следует описание операций. Описание каждой операции имеет следущий вид:

- 1 <span tex="l">l</span> <span tex="r">r</span> <span tex="v">v</span> — присвоить всем элементам на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> значение <span tex="v">v</span> <span tex="(0 ⩽ l < r ⩽ n, 0 ⩽ v ⩽ 10^5)">(0 ⩽ l < r ⩽ n, 0 ⩽ v ⩽ 10^5)</span>.
- 2 <span tex="l">l</span> <span tex="r">r</span> <span tex="v">v</span> — прибавить ко всем элементам на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> число <span tex="v">v</span> <span tex="(0 ⩽ l < r ⩽ n, 0 ⩽ v ⩽ 10^5)">(0 ⩽ l < r ⩽ n, 0 ⩽ v ⩽ 10^5)</span>.
- 3 <span tex="l">l</span> <span tex="r">r</span> — узнать сумму на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> <span tex="(0 ⩽ l < r ⩽ n)">(0 ⩽ l < r ⩽ n)</span>.

### Выходные данные
Для каждой операции третьего типа выведите соответствующее значение.

### Пример
Входные данные
```cpp
5 7
1 0 3 3
2 2 4 2
3 1 3
2 1 5 1
1 0 2 2
3 0 3
3 3 5
```

Выходные данные
```cpp
8
10
4
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/H.cpp)


## I. Криптография

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 1024 мегабайта

Задано <span tex="n">n</span> матриц <span tex="A_1, A_2, …, A_n">A_1, A_2, …, A_n</span> размера <span tex="2 × 2">2 × 2</span>. Необходимо для нескольких запросов вычислить произведение матриц <span tex="A_i, A_{i+1}, …, A_j">A_i, A_{i+1}, …, A_j</span>. Все вычисления производятся по модулю <span tex="r">r</span>.

### Входные данные
Первая строка входного файла содержит числа <span tex="r">r</span> <span tex="(1 ⩽ r ⩽ 10\ 000)">(1 ⩽ r ⩽ 10'000)</span>, <span tex="n">n</span> <span tex="(1 ⩽ n ⩽ 200\ 000)">(1 ⩽ n ⩽ 200'000)</span> и <span tex="m">m</span> <span tex="(1 ⩽ m ⩽ 200\ 000)">(1 ⩽ m ⩽ 200'000)</span>. Следующие <span tex="n">n</span> блоков по две строки содержащие по два числа в строке — описания матриц. Затем следуют <span tex="m">m</span> пар целых чисел от <span tex="1">1</span> до <span tex="n">n</span>, запросы на произведение на отрезке.

### Выходные данные
Выведите <span tex="m">m</span> блоков по две строки, по два числа в каждой — произведения на отрезках. Разделяйте блоки пустой строкой. Все вычисления производятся по модулю <span tex="r">r</span>

### Пример
Входные данные
```cpp
3 4 4
0 1
0 0

2 1
1 2

0 0
0 2

1 0
0 2

1 4
2 3
1 3
2 2
```

Выходные данные
```cpp
0 2
0 0

0 2
0 1

0 1
0 0

2 1
1 2
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/I.cpp)


## J. Землетрясения

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 1024 мегабайта

Город представляет собой последовательность из <span tex="n">n</span> клеток, занумерованных числами от 0 до <span tex="n - 1">n - 1</span>. Изначально все клетки пустые. Далее последовательно происходят <span tex="m">m</span> событий одного из двух типов:

- в клетке <span tex="i">i</span> строится здание с прочностью <span tex="h">h</span> (если в этой клетке уже было здание, оно сносится и заменяется на новое),
- на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> случается землятресение мощностью <span tex="p">p</span>, оно разрушает все здания, прочность которых не больше <span tex="p">p</span>. Ваша задача — для каждого землятресения сказать, сколько зданий оно разрушит.

### Входные данные
Первая строка содержит числа <span tex="n">n</span> и <span tex="m">m</span> — число клеток и число событий <span tex="(1 ⩽ n, m ⩽ 10^5)">(1 ⩽ n, m ⩽ 10^5)</span>. Следующие <span tex="m">m</span> строк содержат описание событий. Описание каждого события имеет следующий вид:

- 1 <span tex="i">i</span> <span tex="h">h</span> — в клетке <span tex="i">i</span> строится здание с прочностью <span tex="h">h</span> <span tex="(0 ⩽ i < n, 1 ⩽ h ⩽ 10^9)">(0 ⩽ i < n, 1 ⩽ h ⩽ 10^9)</span>.
- 2 <span tex="l">l</span> <span tex="r">r</span> <span tex="p">p</span> — на отрезке от <span tex="l">l</span> до <span tex="r - 1">r - 1</span> происходит землятресение с мощностью <span tex="p">p</span> <span tex="(0 ⩽ l < r ⩽ n, 0 ⩽ p ⩽ 10^9)">(0 ⩽ l < r ⩽ n, 0 ⩽ p ⩽ 10^9)</span>.

### Выходные данные
Для каждого события второго типа выведите, сколько зданий было разрушено.

### Пример
Входные данные
```cpp
5 9
1 0 3
1 2 5
2 0 4 3
1 1 4
1 2 7
2 1 3 6
1 3 8
1 4 4
2 0 5 10
```

Выходные данные
```cpp
1
1
3
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/J.cpp)


## K. Художник

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Итальянский художник-абстракционист Ф. Мандарино увлекся рисованием одномерных черно-белых картин. Он пытается найти оптимальное местоположение и количество черных участков картины. Для этого он проводит на прямой белые и черные отрезки, и после каждой из таких операций хочет знать количество черных отрезков на получившейся картине и их суммарную длину.

Изначально прямая — белая. Ваша задача — написать программу, которая после каждой из таких операций выводит в выходной файл интересующие художника данные.

### Входные данные
В первой строке входного файла содержится общее количество нарисованных отрезков <span tex="(1 ⩽ n ⩽ 100\ 000)">(1 ⩽ n ⩽ 100'000)</span>. В последующих <span tex="n">n</span> строках содержится описание операций. Каждая операция описывается строкой вида <span tex="c">c</span> <span tex="x">x</span> <span tex="l">l</span>, где <span tex="c">c</span> — цвет отрезка (`W` для белых отрезков, `B` для черных), а сам отрезок имеет вид <span tex="[x; x+l)">[x; x+l)</span>, причем координаты обоих концов — целые числа, не превосходящие по модулю <span tex="500\ 000">500'000</span>. Длина задается положительным целым числом.

### Выходные данные
После выполнения каждой из операций необходимо вывести в выходной файл на отдельной строке количество черных отрезков на картине и их суммарную длину, разделенные одним пробелом.

### Пример
Входные данные
```cpp
7
W 2 3
B 2 2
B 4 2
B 3 2
B 7 2
W 3 1
W 0 10
```

Выходные данные
```cpp
0 0
1 2
1 4
1 4
2 6
3 5
0 0
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/K.cpp)


## L. Окна

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

На экране расположены прямоугольные окна, каким-то образом перекрывающиеся (со сторонами, параллельными осям координат). Вам необходимо найти точку, которая покрыта наибольшим числом из них.

### Входные данные
В первой строке входного файла записано число окон <span tex="n">n</span> <span tex="(1 ⩽ n ⩽ 50\ 000)">(1 ⩽ n ⩽ 50'000)</span>. Следующие <span tex="n">n</span> строк содержат координаты окон <span tex="x_{(1, i)}\ y_{(1, i)}\ x_{(2, i)}\ y_{(2, i)}">x_(1, i) y_(1, i) x_(2, i) y_(2, i)</span>, где <span tex="(x_{(1, i)}, y_{(1, i)})">(x_(1, i), y_(1, i))</span> — координаты левого верхнего угла <span tex="i">i</span>-го окна, а <span tex="(x_{(2, i)}, y_{(2, i)})">(x_(2, i), y_(2, i))</span> — правого нижнего (на экране компьютера <span tex="y">y</span> растет сверху вниз, а <span tex="x">x</span> — слева направо). Все координаты — целые числа, по модулю не превосходящие <span tex="2·10^5">2·10^5</span>.

### Выходные данные
В первой строке выходного файла выведите максимальное число окон, покрывающих какую-либо из точек в данной конфигурации. Во второй строке выведите два целых числа, разделенные пробелом — координаты точки, покрытой максимальным числом окон. Окна считаются замкнутыми, т.е. покрывающими свои граничные точки.

### Пример
Входные данные
```cpp
2
0 0 3 3
1 1 4 4
```

Выходные данные
```cpp
2
1 3
```

Входные данные
```cpp
1
0 0 1 1
```

Выходные данные
```cpp
1
0 1
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/L.cpp)


## M. Звезды

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Вася любит наблюдать за звездами. Но следить за всем небом сразу ему тяжело. Поэтому он наблюдает только за частью пространства, ограниченной кубом размером <span tex="n × n × n">*n* × *n* × *n*</span>. Этот куб поделен на маленькие кубики размером <span tex="1 × 1 × 1">1 × 1 × 1</span>. Во время его наблюдений могут происходить следующие события:

1. В каком-то кубике появляются или исчезают несколько звезд.
2. К нему может заглянуть его друг Петя и поинтересоваться, сколько видно звезд в части пространства, состоящей из нескольких кубиков.

### Входные данные
Первая строка входного файла содержит натуральное число <span tex="1 ⩽ n ⩽ 128">1 ⩽ *n* ⩽ 128</span>. Координаты кубиков — целые числа от <span tex="0">0</span> до <span tex="n - 1">*n* - 1</span>. Далее следуют записи о происходивших событиях по одной в строке. В начале строки записано число <span tex="m">*m*</span>. Если <span tex="m">*m*</span> равно:

- <span tex="1">1</span>, то за ним следуют 4 числа — <span tex="x, y, z">*x*, *y*, *z*</span> <span tex="(0 ⩽ x, y, z < N)">(0 ⩽ *x*, *y*, *z* < *N*)</span> и <span tex="k">*k*</span> <span tex="(-20000 ⩽ k ⩽ 20000)">(-20000 ⩽ *k* ⩽ 20000)</span> — координаты кубика и величина, на которую в нем изменилось количество видимых звезд;
- <span tex="2">2</span>, то за ним следуют 6 чисел — <span tex="x_1, y_1, z_1, x_2, y_2, z_2">*x1*, *y1*, *z1*, *x2*, *y2*, *z2*</span> <span tex="(0 ⩽ x_1 ⩽ x_2 < N,">(0 ⩽ *x*1 ⩽ *x*2 < *N*,</span> <span tex="0 ⩽ y_1 ⩽ y_2 < N,">0 ⩽ y_1 ⩽ y_2 < N,</span> <span tex="0 ⩽ z_1 ⩽ z_2 < N)">0 ⩽ *z*1 ⩽ *z*2 < *N*)</span>, которые означают, что Петя попросил подсчитать количество звезд в кубиках <span tex="(x, y, z)">(*x*, *y*, *z*)</span> из области: <span tex="x_1 ⩽ x ⩽ x_2">*x*1 ⩽ *x* ⩽ *x*2</span>, <span tex="y_1 ⩽ y ⩽ y_2">*y*1 ⩽ *y* ⩽ *y*2</span>, <span tex="z_1 ⩽ z ⩽ z_2">*z*1 ⩽ *z* ⩽ *z*2</span>;
- <span tex="3">3</span>, то это означает, что Васе надоело наблюдать за звездами и отвечать на вопросы Пети. Эта запись встречается во входном файле только один раз и будет последней.

Количество записей во входном файле не больше <span tex="100\ 002">100'002</span>.

### Выходные данные
Для каждого Петиного вопроса выведите искомое количество звезд.

### Пример
Входные данные
```cpp
2
2 1 1 1 1 1 1
1 0 0 0 1
1 0 1 0 3
2 0 0 0 0 0 0
2 0 0 0 0 1 0
1 0 1 0 -2
2 0 0 0 1 1 1
3
```

Выходные данные
```cpp
0
1
4
2
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/M.cpp)


## <span tex="K">*K*</span>-я порядковая статистика на отрезке

##### Ограничение по времени на тест: 5 секунд
##### Ограничение по памяти на тест: 512 мегабайт

Дан массив из <span tex="N">*N*</span> неотрицательных чисел, строго меньших <span tex="10^9">10^9</span>. Вам необходимо ответить на несколько запросов о величине <span tex="k">*k*</span>-й порядковой статистики на отрезке <span tex="[l, r]">\[*l*, *r*\]</span>.

### Входные данные
Первая строка содержит число <span tex="N">*N*</span> <span tex="(1 ⩽ N ⩽ 450\ 000)">(1 ⩽ *N* ⩽ 450'000)</span> — размер массива.

Вторая строка может быть использована для генерации <span tex="a_i">*a_i*</span> — начальных значений элементов массива. Она содержит три числа <span tex="a_1">*a1*</span>, <span tex="l">*l*</span> и <span tex="m">*m*</span> <span tex="(0 ⩽ a_1, l, m < 10^9)">(0 ⩽ *a1*, *l*, *m* < 10^9)</span>; для <span tex="i">*i*</span> от <span tex="2">2</span> до <span tex="N">*N*</span>

<p tex="a_i = (a_{i - 1} · l + m) \bmod 10^9">
<pre>
TODO
</pre>
</p>

В частности, <span tex="0 ⩽ a_i < 10^9">0 ⩽ *ai* < 10^9</span>.

Третья строка содержит одно целое число <span tex="B">*B*</span> <span tex="(1 ⩽ B ⩽ 1000)">(1 ⩽ *B* ⩽ 1000)</span> — количество групп запросов.

Следующие <span tex="B">*B*</span> строк описывают одну группу запросов. Каждая группа запросов описывается 10 числами. Первое число <span tex="G">*G*</span> обозначает количество запросов в группе. Далее следуют числа <span tex="x_1">*x1*</span>, <span tex="l_x">*lx*</span> и <span tex="m_x">*mx*</span>, затем <span tex="y_1">*y1*</span>, <span tex="l_y">*ly*</span> и <span tex="m_y">*my*</span>, затем, <span tex="k_1">*k1*</span>, <span tex="l_k">*lk*</span> и <span tex="m_k">*mk*</span> <span tex="(1 ⩽ x_1 ⩽ y_1 ⩽ N,">(1 ⩽ *x1* ⩽ *y1* ⩽ *N*,</span> <span tex="1 ⩽ k_1 ⩽ y_1 - x_1 + 1,">1 ⩽ *k1* ⩽ *y1* - *x1* + 1,</span> <span tex="0 ⩽ l_x, m_x, l_y, m_y, l_k, m_k < 10^9)">0 ⩽ *lx*, *mx*, *ly*, *my*, *lk*, *mk* < 10^9)</span>. Эти числа используются для генерации вспомогательных последовательностей <span tex="x_g">*xg*</span> и <span tex="y_g">*yg*</span>, а также параметров запросов <span tex="i_g">*ig*</span>, <span tex="j_g">*jg*</span> и <span tex="k_g">*kg*</span> <span tex="(1 ⩽ g ⩽ G)">(1 ⩽ *g* ⩽ *G*)</span>

<p tex="
\begin{align*}
	x_g &= ((i_{g-1} · l_x + m_x) \bmod N) + 1,                      & 2 ⩽ g ⩽ G  \\\\
	y_g &= ((j_{g-1} · l_y + m_y) \bmod N) + 1,                      & 2 ⩽ g ⩽ G  \\\\
	i_g &= \min(x_g, y_g),                                           & 1 ⩽ g ⩽ G  \\\\
	j_g &= \max(x_g, y_g),                                           & 1 ⩽ g ⩽ G  \\\\
	k_g &= (((k_{g-1} - 1) · l_k + m_k) \bmod (j_g - i_g + 1)) + 1   & 2 ⩽ g ⩽ G
\end{align*}
">
<pre>
TODO
</pre>
</p>

Сгенерированные последовательности описывают запросы, <span tex="g">*g*</span>-й запрос состоит в поиске <span tex="k_g">*kg*</span>-го по величине числа среди элементов отрезка <span tex="[i_g, j_g]">\[*ig*, *jg*\]</span>.

Суммарное количество запросов не превосходит <span tex="600\ 000">600'000</span>.

### Выходные данные
Выведите единственное число — сумму ответов на запросы.

### Пример
Входные данные
```cpp
5
1 1 1
5
1
1 0 0 3 0 0 2 0 0
1
2 0 0 5 0 0 3 0 0
1
1 0 0 5 0 0 5 0 0
1
3 0 0 3 0 0 1 0 0
1
1 0 0 4 0 0 1 0 0
```

Выходные данные
```cpp
15
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Segment%20tree/N.cpp)
