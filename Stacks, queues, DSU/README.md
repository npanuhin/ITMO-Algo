<!-- {{#title ​Стеки, очереди, СНМ}} -->

<h1 align="center">Стеки, очереди, СНМ</h1>


## A. Минимум на стеке

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Вам требуется реализовать структуру данных, выполняющую следующие операции:

-  Добавить элемент <span tex="x">_x_</span> в конец структуры.
-  Удалить последний элемент из структуры.
-  Выдать минимальный элемент в структуре.

### Входные данные
В первой строке входного файла задано одно целое число <span tex="n">_n_</span> — количество операций <span tex="(1 ⩽ n ⩽ 10^6)">(1 ⩽ _n_ ⩽ 10^6)</span>. В следующих <span tex="n">_n_</span> строках заданы сами операции. В <span tex="i">_i_</span>–ой строке число <span tex="ti">_ti_</span> — тип операции (1, если операция добавления. 2, если операция удаления. 3, если операция минимума). Если задана операция добавления, то через пробел записано целое число <span tex="x">_x_</span> — элемент, который следует добавить в структуру <span tex="(−10^9 ⩽ x ⩽ 10^9)">(−10^9 ⩽ _x_ ⩽ 10^9)</span>. Гарантируется, что перед каждой операцией удаления или нахождения минимума структура не пуста.

### Выходные данные
Для каждой операции нахождения минимума выведите одно число — минимальный элемент в структуре. Ответы разделяйте переводом строки.

### Пример
Входные данные
```cpp
8
1 2
1 3
1 -3
3
2
3
2
3
```

Выходные данные
```cpp
-3
2
2
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/A.cpp)


## B. Шарики

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

В одной компьютерной игре игрок выставляет в линию шарики разных цветов. Когда образуется непрерывная цепочка из трех и более шариков одного цвета, она удаляется из линии. Все шарики при этом сдвигаются друг к другу, и ситуация может повториться.

Напишите программу, которая по данной ситуации определяет, сколько шариков будет сейчас уничтожено. Естественно, непрерывных цепочек из трех и более одноцветных шаров в начальный момент может быть не более одной.

### Входные данные
Даны количество шариков в цепочке (не более <span tex="10^5">10^5</span>) и цвета шариков (от 0 до 9, каждому цвету соответствует свое целое число).

### Выходные данные
Требуется вывести количество шариков, которое будет уничтожено.

### Пример
Входные данные
```cpp
5 1 3 3 3 2
```

Выходные данные
```cpp
3
```

Входные данные
```cpp
10 3 3 2 1 1 1 2 2 3 3
```

Выходные данные
```cpp
10
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/B.cpp)


## C. Астроград

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

В Астрополисе прошел концерт популярной группы Астроград. За пару дней до концерта перед кассой выстроилась огромная очередь из людей, желающих туда попасть. Изначально очередь была пуста. В каждый из <span tex="n">_n_</span> моментов времени происходило следующее:

1. В очередь пришел новый человек с уникальным номером <span tex="id">_id_</span>, он встает в очередь последним.
2. Человеку, стоящему спереди очереди, удалось купить билет. Он уходит.
3. Человеку, стоящему последнему в очереди, надоело ждать. Он уходит.
4. Человек с уникальным номером <span tex="q">_q_</span> хочет знать, сколько людей стоит в очереди спереди него.
5. Очередь хочет знать, человек с каким уникальным номером стоит сейчас первым и задерживает всех.

Вам необходимо написать программу, которая умеет обрабатывать описанные события.

### Входные данные
В первой строке дано целое число <span tex="n">_n_</span> <span tex="(1 ⩽ n ⩽ 10^5)">(1 ⩽ _n_ ⩽ 10^5)</span> — количество событий. В каждой из следующих <span tex="n">_n_</span> строк дано описание событий: номер события, а также число <span tex="id">_id_</span> <span tex="(1 ⩽ id ⩽ 10^5)">(1 ⩽ _id_ ⩽ 10^5)</span> для событий типа 1 и число <span tex="q">_q_</span> для событий типа 4. События происходили в том порядке, в каком они описаны во входном файле. Гарантируется корректность всех событий.

### Выходные данные
Выведите ответы для событий типа 4 и 5 в том порядке, в каком они описаны во входном файле.

### Пример
Входные данные
```cpp
7
1 1
5
1 3
3
2
1 2
4 2
```

Выходные данные
```cpp
1
0
```

### Примечание
В примере из условия происходили следующие события:

1.  В очередь пришел человек с <span tex="id = 1">_id_ = 1</span>. Очередь: `[ 1 ]`
2.  Первым в очереди стоит человек с <span tex="id = 1">_id_ = 1</span>. Очередь: `[ 1 ]`
3.  В очередь пришел человек с <span tex="id = 3">_id_ = 3</span>. Очередь: `[ 1, 3 ]`
4.  Последнему в очереди надоело стоять и он уходит. Очередь: `[ 1 ]`
5.  Первому в очереди удалось купить билет и он уходит. Очередь: `[ ]`
6.  В очередь пришел человек с <span tex="id = 2">_id_ = 2</span>. Очередь: `[ 2 ]`
7.  <span tex="q = 2">_q_ = 2</span> хочет знать, сколько человек стоит перед ним. Очередь: `[ 2 ]`

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/C.cpp)


## D. Гоблины и шаманы

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Гоблины Мглистых гор очень любят ходить к своим шаманам. Так как гоблинов много, к шаманам часто образуются очень длинные очереди. А поскольку много гоблинов в одном месте быстро образуют шумную толпу, которая мешает шаманам проводить сложные медицинские манипуляции, последние решили установить некоторые правила касательно порядка в очереди.

Обычные гоблины при посещении шаманов должны вставать в конец очереди. Привилегированные же гоблины, знающие особый пароль, встают ровно в ее середину, причем при нечетной длине очереди они встают сразу за центром.

Так как гоблины также широко известны своим непочтительным отношением ко всяческим правилам и законам, шаманы попросили вас написать программу, которая бы отслеживала порядок гоблинов в очереди.

### Входные данные
В первой строке входных данный записано число <span tex="N">_N_</span> <span tex="(1 ⩽ N ⩽ 5·10^5)">(1 ⩽ _N_ ⩽ 5·10^5 i·j)</span> — количество запросов к программе. Следующие <span tex="N">_N_</span> строк содержат описание запросов в формате:

-  "+ <span tex="i">_i_</span>" - гоблин с номером <span tex="i">_i_</span> <span tex="(1 ⩽ i ⩽ N)">(1 ⩽ _i_ ⩽ _N_)</span> встает в конец очереди.
-  "* <span tex="i">_i_</span>" - привилегированный гоблин с номером <span tex="i">_i_</span> встает в середину очереди.
-  "-" - первый гоблин из очереди уходит к шаманам. Гарантируется, что на момент такого запроса очередь не пуста.

### Выходные данные
Для каждого запроса типа "-" программа должна вывести номер гоблина, который должен зайти к шаманам.

### Пример
Входные данные
```cpp
7
+ 1
+ 2
-
+ 3
+ 4
-
-
```

Выходные данные
```cpp
1
2
3
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/D.cpp)


## E. Постфиксная запись

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел <span tex="A">_A_</span> и <span tex="B">_B_</span> записывается как `A B +`. Запись `B C + D *` обозначает привычное нам `(B + C) * D`, а запись `A B C + D * +` означает `A + (B + C) * D`. Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.

Дано выражение в обратной польской записи. Определите его значение.

### Входные данные
В единственной строке записано выражение в постфиксной записи, содержащее однозначные числа и операции `+`, `-`, `*`. Строка содержит не более 100 чисел и операций.

### Выходные данные
Необходимо вывести значение записанного выражения. Гарантируется, что результат выражения, а также результаты всех промежуточных вычислений по модулю меньше <span tex="2^{31}">2^31</span>.

### Пример
Входные данные
```cpp
8 9 + 1 7 - *
```

Выходные данные
```cpp
-102
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/E.py)


## F. Сортировка стеком

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

### Пример
Входные данные
```cpp
5
5 3 1 2 4
```

Выходные данные
```
push
push
push
pop
push
pop
pop
push
pop
pop
```

Входные данные
```cpp
3
2 3 1
```

Выходные данные
```
impossible
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/F.cpp)


## G. Система непересекающихся множеств

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Реализуйте систему непересекающихся множеств. Вместе с каждым множеством храните минимальный, максимальный элемент в этом множестве и их количество.

### Входные данные
Первая строка входного файла содержит <span tex="n">_n_</span> — количество элементов в носителе <span tex="(1 ⩽ n ⩽ 300\ 000)">(1 ⩽ _n_ ⩽ 300'000)</span>. Далее операций с множеством. Операция `get` должна возвращать минимальный, максимальный элемент в соответствующем множестве, а также их количество.

### Выходные данные
Выведите последовательно результат выполнения всех операций `get`.

### Пример
Входные данные
```py
5
union 1 2
get 3
get 2
union 2 3
get 2
union 1 3
get 5
union 4 5
get 5
union 4 1
get 5
```

Выходные данные
```cpp
3 3 1
1 2 2
1 3 3
5 5 1
4 5 2
1 5 5
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/G.cpp)


## H. Подсчет опыта

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

В очередной онлайн игре игроки, как обычно, сражаются с монстрами и набирают опыт. Для того, чтобы сражаться с монстрами, они объединяются в кланы. После победы над монстром, всем участникам клана, победившего его, добавляется одинаковое число единиц опыта. Особенностью этой игры является то, что кланы никогда не распадаются и из клана нельзя выйти. Единственная доступная операция — объединение двух кланов в один.

Поскольку игроков стало уже много, вам поручили написать систему учета текущего опыта игроков.

### Входные данные
В первой строке входного файла содержатся числа <span tex="n">_n_</span> <span tex="(1 ⩽ n ⩽ 200\ 000)">(1 ⩽ _n_ ⩽ 200'000)</span> и <span tex="m">_m_</span> <span tex="(1 ⩽ m ⩽ 200\ 000)">(1 ⩽ _m_ ⩽ 200'000)</span> — число зарегистрированных игроков и число запросов.

В следующих <span tex="m">_m_</span> строках содержатся описания запросов. Запросы бывают трех типов:

-  `join X Y` — объединить кланы, в которые входят игроки <span tex="X">_X_</span> и <span tex="Y">_Y_</span> (если они уже в одном клане, то ничего не меняется).
-  `add X V` — добавить <span tex="V">_V_</span> единиц опыта всем участникам клана, в который входит игрок <span tex="X">_X_</span> <span tex="(1 ⩽ V ⩽ 100)">(1 ⩽ _V_ ⩽ 100)</span>.
-  `get X` — вывести текущий опыт игрока <span tex="X">_X_</span>.

Изначально у всех игроков 0 опыта и каждый из них состоит в клане, состоящим из него одного.

### Выходные данные
Для каждого запроса get <span tex="X">_X_</span> выведите текущий опыт игрока <span tex="X">_X_</span>.

### Пример
Входные данные
```cpp
3 6
add 1 100
join 1 3
add 1 50
get 1
get 2
get 3
```

Выходные данные
```cpp
150
0
50
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/H.cpp)


## I. Кукушки

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 512 мегабайт

Британские учёные решили заняться орнитологией и понаблюдать за жизнью необычных кукушек. Для этого они вырастили дерево и построили на нём <span tex="n">_n_</span> гнёзд, в каждом из которых живёт кукушка. Наблюдение за деревом состоит в том, что в некоторые моменты времени учёные оценивают, можно ли подложить определённое яйцо в гнездо к некоторой кукушке или нет.

Каждое яйцо может вынашиваться только в двух определённых гнёздах. Каждое яйцо задаётся неупорядоченной парой различных чисел <span tex="(x, y)">(_x_, _y_)</span>. Яйцо <span tex="(x, y)">(_x_, _y_)</span> может вынашиваться в любом из гнёзд <span tex="x">_x_</span> и <span tex="y">_y_</span> и не может вынашиваться в других гнёздах. Обратите внимание, яйцо <span tex="(x, y)">(_x_, _y_)</span> не отличается от яйца <span tex="(y, x)">(_y_, _x_)</span>.

Теперь опишем процесс подкладывания яйца в имеющиеся гнезда: пусть учёные хотят подложить яйцо <span tex="(x, y)">(_x_, _y_)</span>
в гнездо <span tex="x">_x_</span>. Если в гнезде <span tex="x">_x_</span> нет яйца, то яйцо <span tex="(x, y)">(_x_, _y_)</span> просто остаётся в этом гнезде, и процесс на данном шаге завершается. Если же в гнезде <span tex="x">_x_</span> лежит какое-то яйцо <span tex="(x, p)">(_x_, _p_)</span>, то кукушка кладёт яйцо <span tex="(x, y)">(_x_, _y_)</span> в данное гнездо, а яйцо <span tex="(x, p)">(_x_, _p_)</span> пытается подложить в гнездо <span tex="p">_p_</span> аналогичным образом, и процесс продолжается.

Вам предлагается отвечать на вопросы учёных. Всего есть три типа вопросов:

1.  (Теоретический) Закончится ли процесс, если подложить яйцо <span tex="(x, y)">(_x_, _y_)</span> в гнездо <span tex="x">_x_</span>? Так как вопрос чисто теоретический, оно **не добавляется** на самом деле, и состояние гнёзд не меняется.
2.  (Практический) Закончится ли процесс, если подложить яйцо <span tex="(x, y)">(_x_, _y_)</span> в гнездо <span tex="x">_x_</span>? Если процесс закончится, то яйцо **добавляется** в реальности согласно описанному процессу.
3.  (Теоретический) Сколько существует **упорядоченных** пар чисел <span tex="(x, y)">(_x_, _y_)</span>, таких что яйцо <span tex="(x, y)">(_x_, _y_)</span> можно подложить в гнездо <span tex="x">_x_</span> c учётом имеющихся в гнёздах яиц? При этом для каждого яйца ответ определяется независимо от других добавляемых яиц.

### Входные данные
В первой строке вводятся три целых числа <span tex="n">_n_</span>, <span tex="m">_m_</span>, <span tex="q">_q_</span>, <span tex="(2 ⩽ n ⩽ 200\ 000,">(2 ⩽ _n_ ⩽ 200'000,</span> <span tex="0 ⩽ m ⩽ n,">0 ⩽ _m_ ⩽ _n_,</span> <span tex="1 ⩽ q ⩽ 600\ 000)">1 ⩽ _q_ ⩽ 600'000)</span>, где <span tex="n">_n_</span> — количество гнёзд на дереве, <span tex="m">_m_</span> — количество яиц, которые учёные уже положили, <span tex="q">_q_</span> — количество вопросов, которые задают учёные.

В каждой из <span tex="m">_m_</span> последующих строк следуют по два числа <span tex="x_i">_xi_</span>, <span tex="y_i">_yi_</span>, означающих, что в гнезде <span tex="x_i">_xi_</span> лежит яйцо <span tex="(x_i, y_i)">(_xi_, _yi_)</span>. Гарантируется, что все <span tex="x_i">_xi_</span> различны и что <span tex="x_i ≠ y_i">_xi ≠ yi_</span> для всех <span tex="i">_i_</span>.

В следующих <span tex="q">_q_</span> строках описаны вопросы учёных. Вопросы даны в том порядке, в котором на них требуется отвечать. Первое число <span tex="t_j">_tj_</span> в строке описывает тип вопроса.

Если <span tex="t_j = 1">_tj_ = 1</span> или <span tex="t_j = 2">_tj_ = 2</span>, то далее идут два различных числа <span tex="x_j">_xj_</span> и <span tex="y_j">_yj_</span>, описывающих яйцо, которое фигурирует в соответствующем вопросе.

Если <span tex="t_j = 1">_tj_ = 1</span>, то яйцо не требуется добавлять в текущую расстановку.

Если <span tex="t_j = 2">_tj_ = 2</span>, то яйцо требуется добавить, если процесс добавления потребует конечного числа перекладываний.

Если <span tex="t_j = 3">_tj_ = 3</span>, то требуется определить количество упорядоченных пар <span tex="(x, y)">(_x_, _y_)</span>, таких что яйцо <span tex="(x, y)">(_x_, _y_)</span> можно добавить в гнездо <span tex="x">_x_</span> с тем, чтобы процесс когда-нибудь завершился. В реальности никакие яйца в расстановку не добавляются.

### Выходные данные
Для каждого вопроса первого и второго типа выведите единственное слово `Yes` или `No` в зависимости от того, закончится ли процесс перекладывания.

Для каждого запроса третьего типа выведите количество искомых упорядоченных пар.

### Пример
Входные данные
```cpp
5 3 8
1 2
5 1
2 4
1 1 2
3
2 1 2
3
2 4 2
2 5 3
3
1 4 5
```

Выходные данные
```cpp
Yes
20
Yes
8
No
Yes
0
No
```

### Примечание

Изначальное расположение яиц в тесте из условия такое: в первом гнезде лежит яйцо <span tex="(1, 2)">(1, 2)</span>, во втором — <span tex="(2, 4)">(2, 4)</span>, в пятом — <span tex="(5, 1)">(5, 1)</span>, а в третьем и четвёртом яиц нет.

Яйцо <span tex="(1, 2)">(1, 2)</span> добавить можно, несмотря на то что подобное яйцо на дереве уже есть, это приведёт к перекладыванию имеющегося яйца <span tex="(1, 2)">(1, 2)</span> в другое гнездо.

Также в начальную конфигурацию можно добавить любое из 10 яиц, существующих для дерева с пятью гнёздами, и каждое яйцо можно положить в любое из двух гнёзд, ему отвечающих, и для любого из добавляемых яиц и гнёзд это потребует конечное количество шагов. Таким образом, ответ на второй запрос — 20.

В результате следующего запроса яйцо <span tex="(1, 2)">(1, 2)</span> будет добавлено реально, и распределение яиц будет таким: в первом гнезде лежит яйцо <span tex="(1, 2)">(1, 2)</span>, во втором — также <span tex="(1, 2)">(1, 2)</span>, в четвёртом — <span tex="(2, 4)">(2, 4)</span>, в пятом <span tex="(5, 1)">(5, 1)</span>.

Теперь уже можно добавить только яйца <span tex="(1, 3)">(1, 3)</span>, <span tex="(2, 3)">(2, 3)</span>, <span tex="(4, 3)">(4, 3)</span> и <span tex="(5, 3)">(5, 3)</span>, причём по-прежнему любое яйцо можно положить в каждое из двух упомянутых на нём гнёзд, поэтому ответ на запрос — 8.

Яйцо <span tex="(4, 2)">(4, 2)</span> добавить на дерево нельзя, поэтому состояние гнёзд не изменится.

Для добавления яйца <span tex="(5, 3)">(5, 3)</span> понадобится 5 перекладываний яиц, а после этого никакое новое яйцо за конечное количество шагов добавить уже нельзя.

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Stacks,%20queues,%20DSU/I.cpp)
