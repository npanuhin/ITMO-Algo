<!-- {{#title ​Стеки, очереди, СНМ}} -->

<h1 align="center">Стеки, очереди, СНМ</h1>

## A. Минимум на стеке

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Вам требуется реализовать структуру данных, выполняющую следующие операции:

-  Добавить элемент _x_ в конец структуры.
-  Удалить последний элемент из структуры.
-  Выдать минимальный элемент в структуре.

### Входные данные
В первой строке входного файла задано одно целое число _n_ — количество операций (1 ⩽ _n_ ⩽ 10^6). В следующих _n_ строках заданы сами операции. В _i_–ой строке число _ti_ — тип операции (1, если операция добавления. 2, если операция удаления. 3, если операция минимума). Если задана операция добавления, то через пробел записано целое число _x_ — элемент, который следует добавить в структуру (−10^9 ⩽ _x_ ⩽ 10^9). Гарантируется, что перед каждой операцией удаления или нахождения минимума структура не пуста.

### Выходные данные
Для каждой операции нахождения минимума выведите одно число — минимальный элемент в структуре. Ответы разделяйте переводом строки.

### Пример
Входные данные
```cpp
8
1 2
1 3
1 -3
3
2
3
2
3
```

Выходные данные
```cpp
-3
2
2
```

### [Решение](A.cpp)


## B. Шарики

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

В одной компьютерной игре игрок выставляет в линию шарики разных цветов. Когда образуется непрерывная цепочка из трех и более шариков одного цвета, она удаляется из линии. Все шарики при этом сдвигаются друг к другу, и ситуация может повториться.

Напишите программу, которая по данной ситуации определяет, сколько шариков будет сейчас уничтожено. Естественно, непрерывных цепочек из трех и более одноцветных шаров в начальный момент может быть не более одной.

### Входные данные
Даны количество шариков в цепочке (не более 10^5) и цвета шариков (от 0 до 9, каждому цвету соответствует свое целое число).

### Выходные данные
Требуется вывести количество шариков, которое будет уничтожено.

### Пример
Входные данные
```cpp
5 1 3 3 3 2
```

Выходные данные
```cpp
3
```

Входные данные
```cpp
10 3 3 2 1 1 1 2 2 3 3
```

Выходные данные
```cpp
10
```

### [Решение](B.cpp)


## C. Астроград

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

В Астрополисе прошел концерт популярной группы Астроград. За пару дней до концерта перед кассой выстроилась огромная очередь из людей, желающих туда попасть. Изначально очередь была пуста. В каждый из _n_ моментов времени происходило следующее:

1. В очередь пришел новый человек с уникальным номером _id_, он встает в очередь последним.
2. Человеку, стоящему спереди очереди, удалось купить билет. Он уходит.
3. Человеку, стоящему последнему в очереди, надоело ждать. Он уходит.
4. Человек с уникальным номером _q_ хочет знать, сколько людей стоит в очереди спереди него.
5. Очередь хочет знать, человек с каким уникальным номером стоит сейчас первым и задерживает всех.

Вам необходимо написать программу, которая умеет обрабатывать описанные события.

### Входные данные
В первой строке дано целое число _n_ (1 ⩽ _n_ ⩽ 10^5) — количество событий. В каждой из следующих _n_ строк дано описание событий: номер события, а также число _id_ (1 ⩽ _id_ ⩽ 10^5) для событий типа 1 и число _q_ для событий типа 4. События происходили в том порядке, в каком они описаны во входном файле. Гарантируется корректность всех событий.

### Выходные данные
Выведите ответы для событий типа 4 и 5 в том порядке, в каком они описаны во входном файле.

### Пример
Входные данные
```cpp
7
1 1
5
1 3
3
2
1 2
4 2
```

Выходные данные
```cpp
1
0
```

### Примечание
В примере из условия происходили следующие события:

1.  В очередь пришел человек с _id_ = 1. Очередь: `[ 1 ]`
2.  Первым в очереди стоит человек с _id_ = 1. Очередь: `[ 1 ]`
3.  В очередь пришел человек с _id_ = 3. Очередь: `[ 1, 3 ]`
4.  Последнему в очереди надоело стоять и он уходит. Очередь: `[ 1 ]`
5.  Первому в очереди удалось купить билет и он уходит. Очередь: `[ ]`
6.  В очередь пришел человек с _id_ = 2. Очередь: `[ 2 ]`
7.  _q_ = 2 хочет знать, сколько человек стоит перед ним. Очередь: `[ 2 ]`

### [Решение](C.cpp)


## D. Гоблины и шаманы

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Гоблины Мглистых гор очень любят ходить к своим шаманам. Так как гоблинов много, к шаманам часто образуются очень длинные очереди. А поскольку много гоблинов в одном месте быстро образуют шумную толпу, которая мешает шаманам проводить сложные медицинские манипуляции, последние решили установить некоторые правила касательно порядка в очереди.

Обычные гоблины при посещении шаманов должны вставать в конец очереди. Привилегированные же гоблины, знающие особый пароль, встают ровно в ее середину, причем при нечетной длине очереди они встают сразу за центром.

Так как гоблины также широко известны своим непочтительным отношением ко всяческим правилам и законам, шаманы попросили вас написать программу, которая бы отслеживала порядок гоблинов в очереди.

### Входные данные
В первой строке входных данный записано число _N_ (1 ⩽ _N_ ⩽ 5·10^5) - количество запросов к программе. Следующие _N_ строк содержат описание запросов в формате:

-  "+ _i_" - гоблин с номером _i_ (1 ⩽ _i_ ⩽ _N_) встает в конец очереди.
-  "* _i_" - привилегированный гоблин с номером _i_ встает в середину очереди.
-  "-" - первый гоблин из очереди уходит к шаманам. Гарантируется, что на момент такого запроса очередь не пуста.

### Выходные данные
Для каждого запроса типа "-" программа должна вывести номер гоблина, который должен зайти к шаманам.

### Пример
Входные данные
```cpp
7
+ 1
+ 2
-
+ 3
+ 4
-
-
```

Выходные данные
```cpp
1
2
3
```

### [Решение](D.cpp)


## E. Постфиксная запись

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел _A_ и _B_ записывается как `A B +`. Запись `B C + D *` обозначает привычное нам `(B + C) * D`, а запись `A B C + D * +` означает `A + (B + C) * D`. Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.

Дано выражение в обратной польской записи. Определите его значение.

### Входные данные
В единственной строке записано выражение в постфиксной записи, содержащее однозначные числа и операции \+, \-, \*. Строка содержит не более 100 чисел и операций.

### Выходные данные
Необходимо вывести значение записанного выражения. Гарантируется, что результат выражения, а также результаты всех промежуточных вычислений по модулю меньше 2^31.

### Пример
Входные данные
```cpp
8 9 + 1 7 - *
```

Выходные данные
```cpp
-102
```

### [Решение](E.py)


## F. Сортировка стеком

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

### Пример
Входные данные
```cpp
5
5 3 1 2 4
```

Выходные данные
```
push
push
push
pop
push
pop
pop
push
pop
pop
```

Входные данные
```cpp
3
2 3 1
```

Выходные данные
```
impossible
```

### [Решение](F.cpp)


## G. Система непересекающихся множеств

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Реализуйте систему непересекающихся множеств. Вместе с каждым множеством храните минимальный, максимальный элемент в этом множестве и их количество.

### Входные данные
Первая строка входного файла содержит _n_ — количество элементов в носителе (1 ⩽ _n_ ⩽ 300 000). Далее операций с множеством. Операция `get` должна возвращать минимальный, максимальный элемент в соответствующем множестве, а также их количество.

### Выходные данные
Выведите последовательно результат выполнения всех операций `get`.

### Пример
Входные данные
```cpp
5
union 1 2
get 3
get 2
union 2 3
get 2
union 1 3
get 5
union 4 5
get 5
union 4 1
get 5
```

Выходные данные
```cpp
3 3 1
1 2 2
1 3 3
5 5 1
4 5 2
1 5 5
```

### [Решение](G.cpp)


## H. Подсчет опыта

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

В очередной онлайн игре игроки, как обычно, сражаются с монстрами и набирают опыт. Для того, чтобы сражаться с монстрами, они объединяются в кланы. После победы над монстром, всем участникам клана, победившего его, добавляется одинаковое число единиц опыта. Особенностью этой игры является то, что кланы никогда не распадаются и из клана нельзя выйти. Единственная доступная операция — объединение двух кланов в один.

Поскольку игроков стало уже много, вам поручили написать систему учета текущего опыта игроков.

### Входные данные
В первой строке входного файла содержатся числа _n_ (1 ⩽ _n_ ⩽ 200000) и _m_ 1 ⩽ _m_ ⩽ 200000 — число зарегистрированных игроков и число запросов.

В следующих _m_ строках содержатся описания запросов. Запросы бывают трех типов:

-  `join X Y` — объединить кланы, в которые входят игроки _X_ и _Y_ (если они уже в одном клане, то ничего не меняется).
-  `add X V` — добавить _V_ единиц опыта всем участникам клана, в который входит игрок _X_ (1 ⩽ _V_ ⩽ 100).
-  `get X` — вывести текущий опыт игрока _X_.

Изначально у всех игроков 0 опыта и каждый из них состоит в клане, состоящим из него одного.

### Выходные данные
Для каждого запроса get _X_ выведите текущий опыт игрока _X_.

### Пример
Входные данные
```cpp
3 6
add 1 100
join 1 3
add 1 50
get 1
get 2
get 3
```

Выходные данные
```cpp
150
0
50
```

### [Решение](H.cpp)


## I. Кукушки

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 512 мегабайт

Британские учёные решили заняться орнитологией и понаблюдать за жизнью необычных кукушек. Для этого они вырастили дерево и построили на нём _n_ гнёзд, в каждом из которых живёт кукушка. Наблюдение за деревом состоит в том, что в некоторые моменты времени учёные оценивают, можно ли подложить определённое яйцо в гнездо к некоторой кукушке или нет.

Каждое яйцо может вынашиваться только в двух определённых гнёздах. Каждое яйцо задаётся неупорядоченной парой различных чисел (_x_, _y_). Яйцо (_x_, _y_) может вынашиваться в любом из гнёзд _x_ и _y_ и не может вынашиваться в других гнёздах. Обратите внимание, яйцо (_x_, _y_) не отличается от яйца (_y_, _x_).

Теперь опишем процесс подкладывания яйца в имеющиеся гнезда: пусть учёные хотят подложить яйцо (_x_, _y_)
в гнездо _x_. Если в гнезде _x_ нет яйца, то яйцо (_x_, _y_) просто остаётся в этом гнезде, и процесс на данном шаге завершается. Если же в гнезде _x_ лежит какое-то яйцо (_x_, _p_), то кукушка кладёт яйцо (_x_, _y_) в данное гнездо, а яйцо (_x_, _p_) пытается подложить в гнездо _p_ аналогичным образом, и процесс продолжается.

Вам предлагается отвечать на вопросы учёных. Всего есть три типа вопросов:

1.  (Теоретический) Закончится ли процесс, если подложить яйцо (_x_, _y_) в гнездо _x_? Так как вопрос чисто теоретический, оно **не добавляется** на самом деле, и состояние гнёзд не меняется.
2.  (Практический) Закончится ли процесс, если подложить яйцо (_x_, _y_) в гнездо _x_? Если процесс закончится, то яйцо **добавляется** в реальности согласно описанному процессу.
3.  (Теоретический) Сколько существует **упорядоченных** пар чисел (_x_, _y_), таких что яйцо (_x_, _y_) можно подложить в гнездо _x_ c учётом имеющихся в гнёздах яиц? При этом для каждого яйца ответ определяется независимо от других добавляемых яиц.

### Входные данные
В первой строке вводятся три целых числа _n_, _m_, _q_, (2 ⩽ _n_ ⩽ 200000, 0 ⩽ _m_ ⩽ _n_, 1 ⩽ _q_ ⩽ 600000), где _n_ — количество гнёзд на дереве, _m_ — количество яиц, которые учёные уже положили, _q_ — количество вопросов, которые задают учёные.

В каждой из _m_ последующих строк следуют по два числа _xi_, _yi_, означающих, что в гнезде _xi_ лежит яйцо (_xi_, _yi_). Гарантируется, что все _xi_ различны и что _xi ≠ yi_ для всех _i_.

В следующих _q_ строках описаны вопросы учёных. Вопросы даны в том порядке, в котором на них требуется отвечать. Первое число _tj_ в строке описывает тип вопроса.

Если _tj_ = 1 или _tj_ = 2, то далее идут два различных числа _xj_ и _yj_, описывающих яйцо, которое фигурирует в соответствующем вопросе.

Если _tj_ = 1, то яйцо не требуется добавлять в текущую расстановку.

Если _tj_ = 2, то яйцо требуется добавить, если процесс добавления потребует конечного числа перекладываний.

Если _tj_ = 3, то требуется определить количество упорядоченных пар (_x_, _y_), таких что яйцо (_x_, _y_) можно добавить в гнездо _x_ с тем, чтобы процесс когда-нибудь завершился. В реальности никакие яйца в расстановку не добавляются.

### Выходные данные
Для каждого вопроса первого и второго типа выведите единственное слово `Yes` или `No` в зависимости от того, закончится ли процесс перекладывания.

Для каждого запроса третьего типа выведите количество искомых упорядоченных пар.

### Пример
Входные данные
```cpp
5 3 8
1 2
5 1
2 4
1 1 2
3
2 1 2
3
2 4 2
2 5 3
3
1 4 5
```

Выходные данные
```cpp
Yes
20
Yes
8
No
Yes
0
No
```

### Примечание

Изначальное расположение яиц в тесте из условия такое: в первом гнезде лежит яйцо (1, 2), во втором — (2, 4), в пятом — (5, 1), а в третьем и четвёртом яиц нет.

Яйцо (1, 2) добавить можно, несмотря на то что подобное яйцо на дереве уже есть, это приведёт к перекладыванию имеющегося яйца (1, 2) в другое гнездо.

Также в начальную конфигурацию можно добавить любое из 10 яиц, существующих для дерева с пятью гнёздами, и каждое яйцо можно положить в любое из двух гнёзд, ему отвечающих, и для любого из добавляемых яиц и гнёзд это потребует конечное количество шагов. Таким образом, ответ на второй запрос — 20.

В результате следующего запроса яйцо (1, 2) будет добавлено реально, и распределение яиц будет таким: в первом гнезде лежит яйцо (1, 2), во втором — также (1, 2), в четвёртом — (2, 4), в пятом (5, 1).

Теперь уже можно добавить только яйца (1, 3), (2, 3), (4, 3) и (5, 3), причём по-прежнему любое яйцо можно положить в каждое из двух упомянутых на нём гнёзд, поэтому ответ на запрос — 8.

Яйцо (4, 2) добавить на дерево нельзя, поэтому состояние гнёзд не изменится.

Для добавления яйца (5, 3) понадобится 5 перекладываний яиц, а после этого никакое новое яйцо за конечное количество шагов добавить уже нельзя.

### [Решение](I.cpp)
