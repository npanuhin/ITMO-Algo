# Сортировки, куча, бинпоиск

## A. Простая сортировка

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 64 мегабайта
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

В этой задаче вам нужно реализовать любую из пройденных сортировок, работающих за время _O(nlogn)_. Использовать встроенные в язык сортировки и структуры данных запрещается.

Дан массив целых чисел. Ваша задача — отсортировать его в порядке неубывания.

### Входные данные
В первой строке содержится число _n_ (1 ≤ _n_ ≤ 100000) — количество элементов в массиве. Во второй строке находятся _n_ целых чисел, по модулю не превосходящих 10^9.

### Выходные данные
Выведите этот же массив в порядке неубывания.

### Пример
Входные данные
```cpp
10
1 8 2 1 4 7 3 2 3 6
```

Выходные данные
```cpp
1 1 2 2 3 3 4 6 7 8 
```

### [Решение](A.cpp)


## B. Сортировка подсчетом

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 64 мегабайта
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

А в этой задаче вам нужно реализовать сортировку подсчетом. Использовать другие сортировки запрещается.

Дан массив из n элементов, которые принимают целые значения от 0 до 100. Отсортируйте этот массив в порядке неубывания элементов.

### Входные данные
В первой строке содержится число _n_ (1 ≤ _n_ ≤ 200000) — количество элементов в массиве. Во второй строке находятся _n_ целых чисел, от 0 до 100 каждое.

### Выходные данные
Выведите отсортированный массив.

### Пример
Входные данные
```cpp
5
7 3 4 2 5
```

Выходные данные
```cpp
2 3 4 5 7 
```

### [Решение](B.cpp)


## C. Количество инверсий

##### Ограничение по времени на тест: 5 секунд
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Напишите программу, которая для заданного массива _A = ⟨a1, a2, …, an⟩_ находит количество пар _(i, j)_ таких, что _i < j_ и _ai > aj_.

### Входные данные
Первая строка входного файла содержит натуральное число _n_ (1 ≤ _n_ ≤ 500000) — количество элементов массива. Вторая строка содержит _n_ попарно различных элементов массива _A_ (0 ≤ _ai_ ≤ 10^6).

### Выходные данные
В выходной файл выведите одно число — ответ на задачу.

### Пример
Входные данные
```cpp
4
1 2 4 5
```

Выходные данные
```cpp
0
```

Входные данные
```cpp
4
5 4 2 1
```

Выходные данные
```cpp
6
```

### [Решение](C.cpp)


## D. Хипуй!

##### Ограничение по времени на тест: 3 секунды
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

В этой задаче вам необходимо организовать структуру данных Heap для хранения целых чисел, над которой определены следующие операции:

- _Insert(X)_ — добавить в Heap число _X_;
- _Extract_ — достать из Heap наибольшее число (удалив его при этом).

Эту задачу нужно решить без использования встроенных структур данных для поиска максимального числа.

### Входные данные
Во входном файле записано количество команд _n_ (1 ≤ _n_ ≤ 100 000), потом последовательность из _n_ команд, каждая в своей строке.

Каждая команда имеет такой формат: `0 <число>` или `1`, что означает соответственно операции _Insert(<число>)_ и _Extract_. Добавляемые числа находятся в интервале от 1 до 10^7 включительно.

Гарантируется, что при выполнении команды _Extract_ в структуре находится по крайней мере один элемент.

### Выходные данные
В выходной файл для каждой команды извлечения необходимо вывести число, полученное при выполнении команды _Extract_.

### Пример
Входные данные
```cpp
7
0 100
0 10
1
0 5
0 30
0 50
1
```

Выходные данные
```cpp
100
50
```

### [Решение](D.cpp)


## E. Быстрый поиск в массиве

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 512 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Дан массив из n целых чисел. Все числа от −10^9 до 10^9.

Нужно уметь отвечать на запросы вида «Cколько чисел имеют значения от _l_ до _r_»?

### Входные данные
Число _n_ (1 ≤ _n_ ≤ 10^5). Далее _n_ целых чисел.

Затем число запросов _k_ (1 ≤ _k_ ≤ 10^5).

Далее _k_ пар чисел _l_,_r_ (−10^9 ≤ _l_ ≤ _r_ ≤ 10^9) — собственно запросы.

### Выходные данные
Выведите _k_ чисел — ответы на запросы.

### Пример
Входные данные
```cpp
5
10 1 10 3 4
4
1 10
2 9
3 4
2 2
```

Выходные данные
```cpp
5 2 2 0 
```

### [Решение](E.cpp)


## F. Приближенный двоичный поиск

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Даны два массива. Первый массив отсортирован по неубыванию, второй массив содержит запросы — целые числа.

Для каждого запроса выведите число из первого массива наиболее близкое (то есть с минимальным модулем разности) к числу в этом запросе. Если таких несколько, выведите меньшее из них.

### Входные данные
В первой строке входных данных содержатся числа _n_ и _k_ (0 < _n_, _k_ ≤ 10^5). Во второй строке задаются n чисел первого массива, отсортированного по неубыванию, а в третьей строке — _k_ чисел второго массива. Каждое число в обоих массивах по модулю не превосходит 2·10^9.

### Выходные данные
Для каждого из _k_ чисел выведите в отдельную строку число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них.

### Пример
Входные данные
```cpp
5 5
1 3 5 7 9
2 4 8 1 6
```

Выходные данные
```cpp
1
3
7
1
5
```

### [Решение](F.cpp)


## G. Очень Легкая Задача

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Сегодня утром жюри решило добавить в вариант олимпиады еще одну, Очень Легкую Задачу. Ответственный секретарь Оргкомитета напечатал ее условие в одном экземпляре, и теперь ему нужно до начала олимпиады успеть сделать еще _n_ копий. В его распоряжении имеются два ксерокса, один из которых копирует лист за _x_ секунд, а другой — за _y_. (Разрешается использовать как один ксерокс, так и оба одновременно. Можно копировать не только с оригинала, но и с копии.) Помогите ему выяснить, какое минимальное время для этого потребуется.

### Входные данные
На вход программы поступают три натуральных числа _n_, _x_ и _y_, разделенные пробелом (1 ≤ _n_ ≤ 2·10^8, 1 ≤ _x_, _y_ ≤ 10).

### Выходные данные
Выведите одно число — минимальное время в секундах, необходимое для получения _n_ копий.

### Пример
Входные данные
```cpp
4 1 1
```

Выходные данные
```cpp
3
```

Входные данные
```cpp
5 1 2
```

Выходные данные
```cpp
4
```

### [Решение](G.cpp)


## H. Квадратный корень и квадратный квадрат

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Найдите такое число _x_, что _x_^_2_ + _√̅x_, с точностью не менее 6 знаков после точки.

### Входные данные
В единственной строке содержится вещественное число 1.0 ≤ _C_ ≤ 10^10.

### Выходные данные
Выведите одно число — искомый _x_.

### Пример
Входные данные
```cpp
2.0000000000
```

Выходные данные
```cpp
1.0
```

Входные данные
```cpp
18.0000000000
```

Выходные данные
```cpp
4.0
```

### [Решение](H.cpp)


## I. Поляна дров

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Маленький мальчик Ферма́

живет в деревне. Наступают холодные времена, поэтому бабушка попросила мальчика сходить в лес, чтобы собрать дров. В лесу около деревни, в которой живет Ферма, находится волшебная Поляна Дров, на которой всегда лежат дрова, и никогда не кончаются. Естественно, Ферма должен пойти именно туда.

Единственная проблема заключается в том, что идти до Поляны не очень близко, тем более что скорость передвижения по лесу намного меньше, чем скорость передвижения по полю, в котором находится деревня.

- Деревня находится в точке с координатами  (0, 1).
- Поляна находится в точке с координатами  (1, 0).
- Граница между лесом и полем — горизонтальная прямая _y_ = _a_, где _a_ — некоторое число (0 ⩽ _a_ ⩽ 1).
- Скорость передвижения по полю составляет _Vp_, скорость передвижения по лесу — _Vf_. Вдоль границы можно двигаться как по лесу, так и по полю.

Найдите точку, в которой мальчик Ферма должен войти в лес, чтобы дойти до Поляны Дров как можно быстрее.

### Входные данные
В первой строке входного файла содержатся два положительных целых числа — _Vp_ и _Vf_ (1 ⩽ _Vp_, _Vf_ ⩽ 10^5). Во второй строке содержится единственное вещественное число — координата по оси _Oy_ границы между лесом и полем a  (0 ⩽ _a_ ⩽ 1)

### Выходные данные
В единственной строке выходного файла выведите вещественное число с точностью не менее 4 знаков после запятой — координата по оси _Ox_ точки, в которой мальчик Ферма должен войти в лес.

### Пример
Входные данные
```cpp
5 3
0.4
```

Выходные данные
```cpp
0.783310604
```

### [Решение](I.cpp)


## J. K-best

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

У Демьяны есть _n_ драгоценностей. Каждая из драгоценностей имеет ценность _vi_ и вес _wi_. С тех пор, как её мужа Джонни уволили в связи с последним финансовым кризисом, Демьяна решила продать несколько драгоценностей. Для себя она решила оставить лишь _k_ лучших. Лучших в смысле максимизации достаточно специфического выражения: пусть она оставила для себя драгоценности номер _i1_, _i2_, …, _ik_, тогда максимальной должна быть величина
```
∑[j=1..k] vij
─────────────
∑[j=1..k] wij
```
Помогите Демьяне выбрать _k_ драгоценностей требуемым образом.

### Входные данные
На первой строке _n_ и _k_ (1 ≤ _k_ ≤ _n_ ≤ 100000).

Следующие _n_ строк содержат пары целых чисел _vi_, _wi_ (0 ≤ _vi_ ≤ 10^6,1 ≤ _wi_ ≤ 10^6, сумма всех _vi_ не превосходит 10^7, сумма всех _wi_ также не превосходит 10^7).

### Выходные данные
Выведите _k_ различных чисел от 1 до _n_ — номера драгоценностей. Драгоценности нумеруются в том порядке, в котором перечислены во входных данных. Если есть несколько оптимальных ответов, выведите любой.

### Пример
Входные данные
```cpp
3 2
1 1
1 2
1 3
```

Выходные данные
```cpp
1
2
```

### [Решение](J.cpp)


## K. Разделение массива

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Дан массив из _n_ положительных целых чисел. Нужно разбить его на _k_ отрезков так, чтобы максимальная сумма на отрезке была минимально возможной.

### Входные данные
Первая строка содержит целые числа _n_ и _k_ (1 ≤ _k_ ≤ _n_ ≤ 10^5). Вторая строка содержит элементы массива _ai_ (1 ≤ _ai_ ≤ 10^9).

### Выходные данные
Выведите одно число — минимально возможную максимальную сумму на отрезке.

### Пример
Входные данные
```cpp
10 4
1 3 2 4 10 8 4 2 5 3
```

Выходные данные
```cpp
12
```

### [Решение](K.cpp)


## L. Таблица умножения

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Петя составил таблицу умножения размера _n_ × _n_. Ячейка в _i_-й строке и _j_-м столбце содержит значение _i⋅j_. Петю заинтересовал вопрос: какое число в таблице является _k_-м по возрастанию? Помогите Пете ответить на этот вопрос.

### Входные данные
Ввод содержит два целых числа _n_ и _k_ (1 ≤ _n_ ≤ 10^5, 1 ≤ _k_ ≤ _n_^2).

### Выходные данные
Выведите одно число — _k_-е число по возрастанию в таблице.

### Пример
Входные данные
```cpp
3 4
```

Выходные данные
```cpp
3
```

Входные данные
```cpp
5 16
```

Выходные данные
```cpp
10
```

### [Решение](L.cpp)


## M. K-я сумма

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт
##### Ввод: стандартный ввод
##### Вывод: стандартный вывод

Есть два массива _a_ и _b_, каждый из которых состоит из _n_ чисел. Для каждой пары чисел (_i_, _j_): 1 ≤ _i_, _j_ ≤ _n_ выпишем сумму чисел _ai_ + _bj_. Найдите в полученном множестве сумм _k_-ю по возрастанию.

### Входные данные
Первая строка содержит целые числа _n_ и _k_ (1 ≤ _n_ ≤ 10^5, 1 ≤ _k_ ≤ _n_^2). Вторая строка содержит элементы массива _a_, третья строка содержит элементы массива _b_. Все элементы массивов — целые положительные числа, не больше 10^9.

### Выходные данные
Выведите одно число — искомая _k_-я сумма.

### Пример
Входные данные
```cpp
5 10
4 2 6 4 8
7 3 1 9 5
```

Выходные данные
```cpp
9
```

### [Решение](M.cpp)
