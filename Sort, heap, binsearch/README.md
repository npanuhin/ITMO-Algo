<!-- {{#title ​Сортировки, куча, бинпоиск}} -->
<!-- toc[A,B,C,D,E,F,G,H,I,G,K,L,M] -->

<h1 align="center">Сортировки, куча, бинпоиск</h1>


## A. Простая сортировка

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 64 мегабайта

В этой задаче вам нужно реализовать любую из пройденных сортировок, работающих за время <span tex="O(n \log n)">_O(nlogn)_</span>. Использовать встроенные в язык сортировки и структуры данных запрещается.

Дан массив целых чисел. Ваша задача — отсортировать его в порядке неубывания.

### Входные данные
В первой строке содержится число <span tex="n">_n_</span> <span tex="(1 ⩽ n ⩽ 100\ 000)">(1 ⩽ _n_ ⩽ 100'000)</span> — количество элементов в массиве. Во второй строке находятся <span tex="n">_n_</span> целых чисел, по модулю не превосходящих <span tex="10^9">10^9</span>.

### Выходные данные
Выведите этот же массив в порядке неубывания.

### Пример
Входные данные
```cpp
10
1 8 2 1 4 7 3 2 3 6
```

Выходные данные
```cpp
1 1 2 2 3 3 4 6 7 8 
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/A.cpp)


## B. Сортировка подсчетом

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 64 мегабайта

А в этой задаче вам нужно реализовать сортировку подсчетом. Использовать другие сортировки запрещается.

Дан массив из <span tex="n">_n_</span> элементов, которые принимают целые значения от 0 до 100. Отсортируйте этот массив в порядке неубывания элементов.

### Входные данные
В первой строке содержится число <span tex="n">_n_</span> <span tex="(1 ⩽ n ⩽ 200\ 000)">(1 ⩽ _n_ ⩽ 200'000)</span> — количество элементов в массиве. Во второй строке находятся <span tex="n">_n_</span> целых чисел, от 0 до 100 каждое.

### Выходные данные
Выведите отсортированный массив.

### Пример
Входные данные
```cpp
5
7 3 4 2 5
```

Выходные данные
```cpp
2 3 4 5 7 
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/B.cpp)


## C. Количество инверсий

##### Ограничение по времени на тест: 5 секунд
##### Ограничение по памяти на тест: 256 мегабайт

Напишите программу, которая для заданного массива <span tex="A = ⟨a_1, a_2, …, a_n⟩">_A = ⟨a1, a2, …, an⟩_</span> находит количество пар <span tex="(i, j)">_(i, j)_</span> таких, что <span tex="i < j">_i < j_</span> и <span tex="a_i > a_j">_ai > aj_</span>.

### Входные данные
Первая строка входного файла содержит натуральное число <span tex="n">_n_</span> <span tex="(1 ⩽ n ⩽ 500\ 000)">(1 ⩽ _n_ ⩽ 500'000)</span> — количество элементов массива. Вторая строка содержит <span tex="n">_n_</span> попарно различных элементов массива <span tex="A">_A_</span> <span tex="(0 ⩽ a_i ⩽ 10^6)">(0 ⩽ _ai_ ⩽ 10^6)</span>.

### Выходные данные
В выходной файл выведите одно число — ответ на задачу.

### Пример
Входные данные
```cpp
4
1 2 4 5
```

Выходные данные
```cpp
0
```

Входные данные
```cpp
4
5 4 2 1
```

Выходные данные
```cpp
6
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/C.cpp)


## D. Хипуй!

##### Ограничение по времени на тест: 3 секунды
##### Ограничение по памяти на тест: 256 мегабайт

В этой задаче вам необходимо организовать структуру данных Heap для хранения целых чисел, над которой определены следующие операции:

- `Insert(X)` — добавить в Heap число <span tex="X">_X_</span>;
- `Extract` — достать из Heap наибольшее число (удалив его при этом).

Эту задачу нужно решить без использования встроенных структур данных для поиска максимального числа.

### Входные данные
Во входном файле записано количество команд <span tex="n">_n_</span> <span tex="(1 ⩽ n ⩽ 100\ 000)">(1 ⩽ _n_ ⩽ 100'000)</span>, потом последовательность из <span tex="n">_n_</span> команд, каждая в своей строке.

Каждая команда имеет такой формат: `0 <число>` или `1`, что означает соответственно операции `Insert(<число>)` и `Extract`. Добавляемые числа находятся в интервале от <span tex="1">1</span> до <span tex="10^7">10^7</span> включительно.

Гарантируется, что при выполнении команды `Extract` в структуре находится по крайней мере один элемент.

### Выходные данные
В выходной файл для каждой команды извлечения необходимо вывести число, полученное при выполнении команды `Extract`.

### Пример
Входные данные
```cpp
7
0 100
0 10
1
0 5
0 30
0 50
1
```

Выходные данные
```cpp
100
50
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/D.cpp)


## E. Быстрый поиск в массиве

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 512 мегабайт

Дан массив из <span tex="n">_n_</span> целых чисел. Все числа от <span tex="−10^9">−10^9</span> до <span tex="10^9">10^9</span>.

Нужно уметь отвечать на запросы вида «Cколько чисел имеют значения от <span tex="l">_l_</span> до <span tex="r">_r_</span>»?

### Входные данные
Число <span tex="n">_n_</span> <span tex="(1 ⩽ n ⩽ 10^5">(1 ⩽ _n_ ⩽ 10^5</span>). Далее <span tex="n">_n_</span> целых чисел.

Затем число запросов <span tex="k">_k_</span> <span tex="(1 ⩽ k ⩽ 10^5)">(1 ⩽ _k_ ⩽ 10^5)</span>.

Далее <span tex="k">_k_</span> пар чисел <span tex="l, r">_l_,_r_</span> <span tex="(−10^9 ⩽ l ⩽ r ⩽ 10^9)">(−10^9 ⩽ _l_ ⩽ _r_ ⩽ 10^9)</span> — собственно запросы.

### Выходные данные
Выведите <span tex="k">_k_</span> чисел — ответы на запросы.

### Пример
Входные данные
```cpp
5
10 1 10 3 4
4
1 10
2 9
3 4
2 2
```

Выходные данные
```cpp
5 2 2 0 
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/E.cpp)


## F. Приближенный двоичный поиск

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Даны два массива. Первый массив отсортирован по неубыванию, второй массив содержит запросы — целые числа.

Для каждого запроса выведите число из первого массива наиболее близкое (то есть с минимальным модулем разности) к числу в этом запросе. Если таких несколько, выведите меньшее из них.

### Входные данные
В первой строке входных данных содержатся числа <span tex="n">_n_</span> и <span tex="k">_k_</span> <span tex="(0 < n, k ⩽ 10^5)">(0 < _n_, _k_ ⩽ 10^5)</span>. Во второй строке задаются <span tex="n">_n_</span> чисел первого массива, отсортированного по неубыванию, а в третьей строке — <span tex="k">_k_</span> чисел второго массива. Каждое число в обоих массивах по модулю не превосходит <span tex="2 \cdot 10^9">2·10^9</span>.

### Выходные данные
Для каждого из <span tex="k">_k_</span> чисел выведите в отдельную строку число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них.

### Пример
Входные данные
```cpp
5 5
1 3 5 7 9
2 4 8 1 6
```

Выходные данные
```cpp
1
3
7
1
5
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/F.cpp)


## G. Очень Легкая Задача

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Сегодня утром жюри решило добавить в вариант олимпиады еще одну, Очень Легкую Задачу. Ответственный секретарь Оргкомитета напечатал ее условие в одном экземпляре, и теперь ему нужно до начала олимпиады успеть сделать еще <span tex="n">_n_</span> копий. В его распоряжении имеются два ксерокса, один из которых копирует лист за <span tex="x">_x_</span> секунд, а другой — за <span tex="y">_y_</span>. (Разрешается использовать как один ксерокс, так и оба одновременно. Можно копировать не только с оригинала, но и с копии.) Помогите ему выяснить, какое минимальное время для этого потребуется.

### Входные данные
На вход программы поступают три натуральных числа <span tex="n">_n_</span>, <span tex="x">_x_</span> и <span tex="y">_y_</span>, разделенные пробелом <span tex="(1 ⩽ n ⩽ 2 \cdot 10^8, 1 ⩽ x, y ⩽ 10)">(1 ⩽ _n_ ⩽ 2·10^8, 1 ⩽ _x_, _y_ ⩽ 10)</span>.

### Выходные данные
Выведите одно число — минимальное время в секундах, необходимое для получения <span tex="n">_n_</span> копий.

### Пример
Входные данные
```cpp
4 1 1
```

Выходные данные
```cpp
3
```

Входные данные
```cpp
5 1 2
```

Выходные данные
```cpp
4
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/G.cpp)


## H. Квадратный корень и квадратный квадрат

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Найдите такое число <span tex="x">_x_</span>, что <span tex="x^2 + \sqrt{x}">_x_^_2_ + _√̅x_</span>, с точностью не менее 6 знаков после точки.

### Входные данные
В единственной строке содержится вещественное число <span tex="1.0 ⩽ C ⩽ 10^{10}">1.0 ⩽ _C_ ⩽ 10^10</span>.

### Выходные данные
Выведите одно число — искомый <span tex="x">_x_</span>.

### Пример
Входные данные
```cpp
2.0000000000
```

Выходные данные
```cpp
1.0
```

Входные данные
```cpp
18.0000000000
```

Выходные данные
```cpp
4.0
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/H.cpp)


## I. Поляна дров

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

Маленький мальчик Ферма́ живет в деревне. Наступают холодные времена, поэтому бабушка попросила мальчика сходить в лес, чтобы собрать дров. В лесу около деревни, в которой живет Ферма, находится волшебная Поляна Дров, на которой всегда лежат дрова, и никогда не кончаются. Естественно, Ферма должен пойти именно туда.

Единственная проблема заключается в том, что идти до Поляны не очень близко, тем более что скорость передвижения по лесу намного меньше, чем скорость передвижения по полю, в котором находится деревня.

- Деревня находится в точке с координатами <span tex="(0, 1)">(0, 1)</span>.
- Поляна находится в точке с координатами <span tex="(1, 0)">(1, 0)</span>.
- Граница между лесом и полем — горизонтальная прямая <span tex="y = a">_y_ = _a_</span>, где <span tex="a">_a_</span> — некоторое число <span tex="(0 ⩽ a ⩽ 1)">(0 ⩽ _a_ ⩽ 1)</span>.
- Скорость передвижения по полю составляет <span tex="V_p">_Vp_</span>, скорость передвижения по лесу — <span tex="V_f">_Vf_</span>. Вдоль границы можно двигаться как по лесу, так и по полю.

Найдите точку, в которой мальчик Ферма должен войти в лес, чтобы дойти до Поляны Дров как можно быстрее.

### Входные данные
В первой строке входного файла содержатся два положительных целых числа — <span tex="V_p">_Vp_</span> и <span tex="V_f">_Vf_</span> <span tex="(1 ⩽ V_p, V_f ⩽ 10^5)">(1 ⩽ _Vp_, _Vf_ ⩽ 10^5)</span>. Во второй строке содержится единственное вещественное число — координата по оси <span tex="O_y">_Oy_</span> границы между лесом и полем <span tex="a">_a_</span> <span tex="(0 ⩽ a ⩽ 1)">(0 ⩽ _a_ ⩽ 1)</span>

### Выходные данные
В единственной строке выходного файла выведите вещественное число с точностью не менее 4 знаков после запятой — координата по оси <span tex="O_x">_Ox_</span> точки, в которой мальчик Ферма должен войти в лес.

### Пример
Входные данные
```cpp
5 3
0.4
```

Выходные данные
```cpp
0.783310604
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/I.cpp)


## J. K-best

##### Ограничение по времени на тест: 2 секунды
##### Ограничение по памяти на тест: 256 мегабайт

У Демьяны есть <span tex="n">_n_</span> драгоценностей. Каждая из драгоценностей имеет ценность <span tex="v_i">_vi_</span> и вес <span tex="w_i">_wi_</span>. С тех пор, как её мужа Джонни уволили в связи с последним финансовым кризисом, Демьяна решила продать несколько драгоценностей. Для себя она решила оставить лишь <span tex="k">_k_</span> лучших. Лучших в смысле максимизации достаточно специфического выражения: пусть она оставила для себя драгоценности номер <span tex="i_1, i_2, …, i_k">_i1_, _i2_, …, _ik_</span>, тогда максимальной должна быть величина

<p tex="\frac{\sum\limits_{j=1}^{k}v_{i_j}}{\sum\limits_{j=1}^{k}w_{i_j}}">
<pre>
∑[j=1..k] vij
─────────────
∑[j=1..k] wij
</pre>
</p>

Помогите Демьяне выбрать <span tex="k">_k_</span> драгоценностей требуемым образом.

### Входные данные
На первой строке <span tex="n">_n_</span> и <span tex="k">_k_</span> <span tex="(1 ⩽ k ⩽ n ⩽ 100\ 000)">(1 ⩽ _k_ ⩽ _n_ ⩽ 100'000)</span>.

Следующие <span tex="n">_n_</span> строк содержат пары целых чисел <span tex="v_i">_vi_</span>, <span tex="w_i">_wi_</span> <span tex="(0 ⩽ v_i ⩽ 10^6,">(0 ⩽ _vi_ ⩽ 10^6,</span> <span tex="1 ⩽ w_i ⩽ 10^6)">1 ⩽ _wi_ ⩽ 10^6)</span>, сумма всех <span tex="v_i">_vi_</span> не превосходит <span tex="10^7">10^7</span>, сумма всех <span tex="w_i">_wi_</span> также не превосходит <span tex="10^7)">10^7)</span>.

### Выходные данные
Выведите <span tex="k">_k_</span> различных чисел от <span tex="1">1</span> до <span tex="n">_n_</span> — номера драгоценностей. Драгоценности нумеруются в том порядке, в котором перечислены во входных данных. Если есть несколько оптимальных ответов, выведите любой.

### Пример
Входные данные
```cpp
3 2
1 1
1 2
1 3
```

Выходные данные
```cpp
1
2
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/J.cpp)


## K. Разделение массива

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

Дан массив из <span tex="n">_n_</span> положительных целых чисел. Нужно разбить его на <span tex="k">_k_</span> отрезков так, чтобы максимальная сумма на отрезке была минимально возможной.

### Входные данные
Первая строка содержит целые числа <span tex="n">_n_</span> и <span tex="k">_k_</span> <span tex="(1 ⩽ k ⩽ n ⩽ 10^5)">(1 ⩽ _k_ ⩽ _n_ ⩽ 10^5)</span>. Вторая строка содержит элементы массива <span tex="a_i">_ai_</span> <span tex="(1 ⩽ a_i ⩽ 10^9)">(1 ⩽ _ai_ ⩽ 10^9)</span>.

### Выходные данные
Выведите одно число — минимально возможную максимальную сумму на отрезке.

### Пример
Входные данные
```cpp
10 4
1 3 2 4 10 8 4 2 5 3
```

Выходные данные
```cpp
12
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/K.cpp)


## L. Таблица умножения

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

Петя составил таблицу умножения размера <span tex="n \times n">_n_ × _n_</span>. Ячейка в <span tex="i">_i_</span>-й строке и <span tex="j">_j_</span>-м столбце содержит значение <span tex="i · j">_i·j_</span>. Петю заинтересовал вопрос: какое число в таблице является <span tex="k">_k_</span>-м по возрастанию? Помогите Пете ответить на этот вопрос.

### Входные данные
Ввод содержит два целых числа <span tex="n">_n_</span> и <span tex="k">_k_</span> <span tex="(1 ⩽ n ⩽ 10^5, 1 ⩽ k ⩽ n^2)">(1 ⩽ _n_ ⩽ 10^5, 1 ⩽ _k_ ⩽ _n_^2)</span>.

### Выходные данные
Выведите одно число — <span tex="k">_k_</span>-е число по возрастанию в таблице.

### Пример
Входные данные
```cpp
3 4
```

Выходные данные
```cpp
3
```

Входные данные
```cpp
5 16
```

Выходные данные
```cpp
10
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/L.cpp)


## M. K-я сумма

##### Ограничение по времени на тест: 1 секунда
##### Ограничение по памяти на тест: 256 мегабайт

Есть два массива <span tex="a">_a_</span> и <span tex="b">_b_</span>, каждый из которых состоит из <span tex="n">_n_</span> чисел. Для каждой пары чисел <span tex="(i, j): 1 ⩽ i, j ⩽ n">(_i_, _j_): 1 ⩽ _i_, _j_ ⩽ _n_</span> выпишем сумму чисел <span tex="a_i + b_j">_ai_ + _bj_</span>. Найдите в полученном множестве сумм <span tex="k">_k_</span>-ю по возрастанию.

### Входные данные
Первая строка содержит целые числа <span tex="n">_n_</span> и <span tex="k">_k_</span> <span tex="(1 ⩽ n ⩽ 10^5, 1 ⩽ k ⩽ n^2)">(1 ⩽ _n_ ⩽ 10^5, 1 ⩽ _k_ ⩽ _n_^2)</span>. Вторая строка содержит элементы массива <span tex="a">_a_</span>, третья строка содержит элементы массива <span tex="b">_b_</span>. Все элементы массивов — целые положительные числа, не больше <span tex="10^9">10^9</span>.

### Выходные данные
Выведите одно число — искомая <span tex="k">_k_</span>-я сумма.

### Пример
Входные данные
```cpp
5 10
4 2 6 4 8
7 3 1 9 5
```

Выходные данные
```cpp
9
```

### [Решение](https://github.com/npanuhin/ITMO-Algo/blob/master/Sort,%20heap,%20binsearch/M.cpp)
